
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>yuuuu.wang`blog</title>
  <meta name="author" content="wang yu">

  
  <meta name="description" content="&lt;!doctype html> 所有浏览器都支持 &lt;!DOCTYPE> 声明。
&lt;!DOCTYPE> 声明必须是 HTML 文档的第一行，位于 标签之前。
&lt;!DOCTYPE> 声明不是 HTML 标签；它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://juelite.github.io/posts/2/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="yuuuu.wang`blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//apps.bdimg.com/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!-- <link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">-->
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">yuuuu.wang`blog</a></h1>
  
    <h2>power by wang yu</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="juelite.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/31/html-doctype/">html-DocType</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-08-31T19:29:52+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>31</span><span class='date-suffix'>st</span>, <span class='date-year'>2014</span></span> <span class='time'>7:29 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>&lt;!doctype html></p>

<ol>
<li>所有浏览器都支持 &lt;!DOCTYPE> 声明。</li>
<li>&lt;!DOCTYPE> 声明必须是 HTML 文档的第一行，位于 <html> 标签之前。</li>
<li>&lt;!DOCTYPE> 声明不是 HTML 标签；它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。</li>
<li>在 HTML 4.01 中，&lt;!DOCTYPE> 声明引用 DTD，因为 HTML 4.01 基于 SGML。</li>
<li>DTD 规定了标记语言的规则，这样浏览器才能正确地呈现内容。</li>
<li>HTML5 不基于 SGML，所以不需要引用 DTD。</li>
<li>&lt;!DOCTYPE> 声明没有结束标签。</li>
<li>&lt;!DOCTYPE> 声明对大小写不敏感。</li>
</ol>


<p>提示：请始终向 HTML 文档添加 &lt;!DOCTYPE> 声明，这样浏览器才能获知文档类型。</p>

<ul>
<li>HTML        1991</li>
<li>HTML+       1993</li>
<li>HTML 2.0    1995</li>
<li>HTML 3.2    1997</li>
<li>HTML 4.01   1999</li>
<li>XHTML 1.0   2000</li>
<li>HTML5       2012</li>
<li>XHTML5      2013</li>
</ul>


<p>常用的 DOCTYPE 声明如下
HTML 5
&lt;!DOCTYPE html></p>

<h3>HTML 4.01 Strict</h3>

<p>该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。
&lt;!DOCTYPE HTML PUBLIC &ldquo;-//W3C//DTD HTML 4.01//EN&rdquo; &ldquo;<a href="http://www.w3.org/TR/html4/strict.dtd">http://www.w3.org/TR/html4/strict.dtd</a>&rdquo;></p>

<h3>HTML 4.01 Transitional</h3>

<p>该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。
&lt;!DOCTYPE HTML PUBLIC &ldquo;-//W3C//DTD HTML 4.01 Transitional//EN&rdquo; &ldquo;<a href="http://www.w3.org/TR/html4/loose.dtd">http://www.w3.org/TR/html4/loose.dtd</a>&rdquo;></p>

<h3>HTML 4.01 Frameset</h3>

<p>该 DTD 等同于 HTML 4.01 Transitional，但允许框架集内容。
&lt;!DOCTYPE HTML PUBLIC &ldquo;-//W3C//DTD HTML 4.01 Frameset//EN&rdquo; &ldquo;<a href="http://www.w3.org/TR/html4/frameset.dtd">http://www.w3.org/TR/html4/frameset.dtd</a>&rdquo;></p>

<h3>XHTML 1.0 Strict</h3>

<p>该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。
&lt;!DOCTYPE html PUBLIC &ldquo;-//W3C//DTD XHTML 1.0 Strict//EN&rdquo; &ldquo;<a href="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd</a>&rdquo;></p>

<h3>XHTML 1.0 Transitional</h3>

<p>该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。
&lt;!DOCTYPE html PUBLIC &ldquo;-//W3C//DTD XHTML 1.0 Transitional//EN&rdquo; &ldquo;<a href="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd</a>&rdquo;></p>

<h3>XHTML 1.0 Frameset</h3>

<p>该 DTD 等同于 XHTML 1.0 Transitional，但允许框架集内容。
&lt;!DOCTYPE html PUBLIC &ldquo;-//W3C//DTD XHTML 1.0 Frameset//EN&rdquo; &ldquo;<a href="http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd</a>&rdquo;></p>

<h3>XHTML 1.1</h3>

<p>该 DTD 等同于 XHTML 1.0 Strict，但允许添加模型（例如提供对东亚语系的 ruby 支持）。
&lt;!DOCTYPE html PUBLIC &ldquo;-//W3C//DTD XHTML 1.1//EN&rdquo; &ldquo;<a href="http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd</a>&rdquo;></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/31/linux-useful-command/">Linux-有用的命令</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-08-31T18:57:18+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>31</span><span class='date-suffix'>st</span>, <span class='date-year'>2014</span></span> <span class='time'>6:57 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>下面我将和大家分享一些学习Linux命令行的技巧，希望能对大家有所助益。如果在本文中遇到不太熟悉的命令，可以在终端中键入以下命令寻求帮助。
Man <command>
 Linux入门必备
了解bash：没有必要钻研长篇累牍的bash使用手册，通过man bash学习即可。
了解vi：你在工作中也许会使用Emacs或Eclipse，但vi不可替代。
了解ssh：学习无密码验证的基础知识。
bash作业管理基础知识：如使用&amp;、Ctrl-C、fg、bg、Ctrl-Z、jobs和kill等。
文件管理命令：如硬链接和软链接，权限等。
网络管理命令：如ifconfig等。
如何使用正则表达式，如何使用grep、sed等。
学习使用apt-get和yum管理软件包。
提升日常工作效率</p>

<p>在bash中，可以使用Ctrl+R命令搜索命令行历史记录。
在bash中，可以使用Ctrl+W删除最后一个单词，使用Ctrl+U删除整行。
使用cd -命令返回之前的工作目录，使用cd ..命令返回上层目录。
学习如何使用xargs：
$ find . -name *.py | xargs grep some_function<br/>
$ cat hosts | xargs -I{} ssh root@{} hostnameX
使用pstree -p命令查看进程树。
了解不同的信号。例如，使用kill -STOP [PID]终止进程。详细的信号列表可以在man 7 signal中查看。
如果你想让进程永远在后台运行，可以使用nohup和disown命令。
使用netstat -lntp命令查看侦听进程，并参考lsof命令。
在bash脚本中使用subshells对命令进行分组：</p>

<h1>do something in current dir</h1>

<p>(cd /some/other/dir; other-command)</p>

<h1>continue in original dir</h1>

<p>字符串修剪（Trimming Strings）：${var%suffix}和${var#prefix}。例如if var=foo.pdf then echo ${var%.pdf}.txt prints &ldquo;foo.txt"。
命令的输出可以当做文件使用。例如，比较本地和远程的/etc/hosts文件：
diff /etc/hosts &lt;(ssh somehost cat /etc/hosts)
了解bash中的“here documents”。
了解标准输出和标准错误重定向。
了解ASCII代码表。可以在终端中运行man ascii命令作为参考。
当通过ssh远程工作时，可以使用screen 或 dtach保存回话。
对Web开发者而言，curl、wget等命令非常实用。
将HTML页面转化文本文件：
lynx -dump -stdin
如果要掌握XML，xmlstarlet命令是非常好的工具。
了解ssh端口映射。
使用Alt+shift+3快捷键可以在行前添加注释“#”。
数据处理</p>

<p>了解sort和uniq命令。
了解cut、paste和join命令。
了解如何对文本文件做交集、并集和差集：
cat a b | sort | uniq > c # c is a union b<br/>
cat a b | sort | uniq -d > c # c is a intersect b<br/>
cat a b b | sort | uniq -u > c # c is set difference a – b
对文本文件的第二列做摘要，下面的代码要比同样的Python代码更精炼、快速（3倍）：
awk &lsquo;{ x += $2 } END { print x }&rsquo;
了解字符串和grep命令。
文件分割：了解split（按大小分割）和csplit（按匹配分割）命令。
系统诊断</p>

<p>使用iostat、netstat、top和dstat命令查看磁盘、处理器和网络的状态。
使用free、vmstat等命令了解系统内存状态。
使用mtr网络诊断工具。
使用iftop、nethogs等工具查看占用带宽的进程和带宽。
使用ab工具快速洞悉Web服务器的性能。
以wireshark和tshark命令应对复杂网络诊断。
学习如何使用strace，并用于诊断运行的进程。这对分析程序运行错误的原因，非常有帮助。
使用ldd命令查看共享库文件。
了解如何使用gdb连接到运行中的进程，并进行堆栈跟踪。
有关/proc的知识非常重要。
如何诊断已发生的错误？Sar命令是一种很好的选择，它可以收集、保存并报告系统信息。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/31/apache-http-request-process/">Apache处理http请求的生命周期</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-08-31T09:49:40+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>31</span><span class='date-suffix'>st</span>, <span class='date-year'>2014</span></span> <span class='time'>9:49 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Apache请求处理循环的11个阶段都做了哪些事情呢？</p>

<ol>
<li>Post-Read-Request阶段: 在正常请求处理流程中，这是模块可以插入钩子的第一个阶段。对于那些想很早进入处理请求的模块来说，这个阶段可以被利用。</li>
<li>URI Translation阶段 :  Apache在本阶段的主要工作：将请求的URL映射到本地文件系统。模块可以在这阶段插入钩子，执行自己的映射逻辑。mod_alias就是利用这个阶段工作的。</li>
<li>Header Parsing阶段 : Apache在本阶段的主要工作：检查请求的头部。由于模块可以在请求处理流程的任何一个点上执行检查请求头部的任务，因此这个钩子很少被使用。mod_setenvif就是利用这个阶段工作的。</li>
<li>Access Control阶段 :  Apache在本阶段的主要工作：根据配置文件检查是否允许访问请求的资源。Apache的标准逻辑实现了允许和拒绝指令。mod_authz_host就是利用这个阶段工作的。</li>
<li>Authentication阶段 :  Apache在本阶段的主要工作：按照配置文件设定的策略对用户进行认证，并设定用户名区域。模块可以在这阶段插入钩子，实现一个认证方法。</li>
<li>Authorization阶段 :  Apache在本阶段的主要工作：根据配置文件检查是否允许认证过的用户执行请求的操作。模块可以在这阶段插入钩子，实现一个用户权限管理的方法。</li>
<li>MIME Type Checking阶段 :  Apache在本阶段的主要工作：根据请求资源的MIME类型的相关规则，判定将要使用的内容处理函数。标准模块mod_negotiation和mod_mime实现了这个钩子。</li>
<li>FixUp阶段 :  这是一个通用的阶段，允许模块在内容生成器之前，运行任何必要的处理流程。和Post_Read_Request类似，这是一个能够捕获任何信息的钩子，也是最常使用的钩子。</li>
<li>Response阶段 : Apache在本阶段的主要工作：生成返回客户端的内容，负责给客户端发送一个恰当的回复。这个阶段是整个处理流程的核心部分。</li>
<li>Logging阶段 :  Apache在本阶段的主要工作：在回复已经发送给客户端之后记录事务。模块可能修改或者替换Apache的标准日志记录。</li>
<li>CleanUp阶段 : Apache在本阶段的主要工作：清理本次请求事务处理完成之后遗留的环境，比如文件、目录的处理或者Socket的关闭等等，这是Apache一次请求处理的最后一个阶段。</li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/31/php-break-keywork/">PHP Break 关键字</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-08-31T09:26:19+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>31</span><span class='date-suffix'>st</span>, <span class='date-year'>2014</span></span> <span class='time'>9:26 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>php的break关键字可以接受一个可选的数字参数来决定跳出几重循环
break 结束当前 for，foreach，while，do-while 或者 switch 结构的执行。
break可以接受一个可选的数字参数来决定跳出几重循环。</p>

<pre><code>&lt;?php
    $arr = array('one', 'two', 'three', 'four', 'stop', 'five');
    while (list (, $val) = each($arr)) {
        if ($val == 'stop') {
            break;    /* You could also write 'break 1;' here. */
        }
        echo "$val&lt;br /&gt;\n";
    }

    /* Using the optional argument. */

    $i = 0;
    while (++$i) {
        switch ($i) {
        case 5:
            echo "At 5&lt;br /&gt;\n";
            break 1;  /* Exit only the switch. */
        case 10:
            echo "At 10; quitting&lt;br /&gt;\n";
            break2;  /* Exit the switch and the while. */
        default:
            break;
        }
    }
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/20/octopress-add-category2rightaside/">Octopress添加分类到侧边栏</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-05-20T23:02:11+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>11:02 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>增加category_list插件</h2>

<p>保存以下代码到plugins/category_list_tag.rb：</p>

<pre><code>module Jekyll
  class CategoryListTag &lt; Liquid::Tag
    def render(context)
      html = ""
      categories = context.registers[:site].categories.keys
      categories.sort.each do |category|
        posts_in_category = context.registers[:site].categories[category].size
        category_dir = context.registers[:site].config['category_dir']
        category_url = File.join(category_dir, category.gsub(/_|\P{Word}/, '-').gsub(/-{2,}/, '-').downcase)
        html &lt;&lt; "&lt;li class='category'&gt;&lt;a href='/#{category_url}/'&gt;#{category} (#{posts_in_category})&lt;/a&gt;&lt;/li&gt;\n"
      end
      html
    end
  end
end
</code></pre>

<p>Liquid::Template.register_tag(&lsquo;category_list&rsquo;, Jekyll::CategoryListTag)<br/>
这个插件会向liquid注册一个名为category_list的tag，该tag就是以li的形式将站点所有的category组织起来。如果要将category加入到侧边导航栏，需要增加一个aside。</p>

<h2>增加aside</h2>

<p>复制以下代码到source/_includes/asides/category_list.html。</p>

<pre><code>&lt;section&gt;
  &lt;h1&gt;Categories&lt;/h1&gt;
  &lt;ul id="categories"&gt;
    { % category_list % }
  &lt;/ul&gt;
&lt;/section&gt;
</code></pre>

<h2>配置侧边栏需要修改_config.yml文件，修改其default_asides项：</h2>

<p>default_asides: [asides/category_list.html, asides/recent_posts.html]<br/>
以上asides根据自己的需求调整。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/01/31/consistent-hashing/">一致性哈希算法浅析</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-01-31T10:27:40+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>31</span><span class='date-suffix'>st</span>, <span class='date-year'>2014</span></span> <span class='time'>10:27 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在做服务器负载均衡时候可供选择的负载均衡的算法有很多，包括：</p>

<ul>
<li>轮循算法（Round Robin）</li>
<li>哈希算法（HASH）</li>
<li>最少连接算法（Least Connection）</li>
<li>响应速度算法（Response Time）</li>
<li>加权法（Weighted ）等</li>
</ul>


<p> 其中哈希算法是最为常用的算法.
典型的应用场景是： 有N台服务器提供缓存服务，需要对服务器进行负载均衡，将请求平均分发到每台服务器上，每台机器负责1/N的服务。
常用的算法是对hash结果取余数 (hash() mod N)：对机器编号从0到N-1，按照自定义的hash()算法，对每个请求的hash()值按N取模，得到余数i，然后将请求分发到编号为i的机器。但这样的算法方法存在致命问题，如果某一台机器宕机，那么应该落在该机器的请求就无法得到正确的处理，这时需要将当掉的服务器从算法从去除，此时候会有(N-1)/N的服务器的缓存数据需要重新进行计算；如果新增一台机器，会有N /(N+1)的服务器的缓存数据需要进行重新计算。对于系统而言，这通常是不可接受的颠簸（因为这意味着大量缓存的失效或者数据需要转移）。那么，如何设计一个负载均衡策略，使得受到影响的请求尽可能的少呢？
在Memcached、Key-Value Store、Bittorrent DHT、LVS中都采用了Consistent Hashing算法，可以说Consistent Hashing 是分布式系统负载均衡的首选算法。
1、Consistent Hashing算法描述
下面以Memcached中的Consisten Hashing算法为例说明。
由于hash算法结果一般为unsigned int型，因此对于hash函数的结果应该均匀分布在[0,232-1]间，如果我们把一个圆环用232 个点来进行均匀切割，首先按照hash(key)函数算出服务器（节点）的哈希值， 并将其分布到0～232的圆上。
用同样的hash(key)函数求出需要存储数据的键的哈希值，并映射到圆上。然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器（节点）上。</p>

<p><img src="/images/consistent-hashing-01.png" alt="consistent hashing" /></p>

<p>Consistent Hashing原理示意图
新增一个节点的时候，只有在圆环上新增节点逆时针方向的第一个节点的数据会受到影响。删除一个节点的时候，只有在圆环上原来删除节点顺时针方向的第一个节点的数据会受到影响，因此通过Consistent Hashing很好地解决了负载均衡中由于新增节点、删除节点引起的hash值颠簸问题。</p>

<p><img src="/images/consistent-hashing-02.png" alt="consistent hashing" /></p>

<p>Consistent Hashing添加服务器示意图
虚拟节点（virtual nodes）：之所以要引进虚拟节点是因为在服务器（节点）数较少的情况下（例如只有3台服务器），通过hash(key)算出节点的哈希值在圆环上并不是均匀分布的（稀疏的），仍然会出现各节点负载不均衡的问题。虚拟节点可以认为是实际节点的复制品（replicas），本质上与实际节点实际上是一样的（key并不相同）。引入虚拟节点后，通过将每个实际的服务器（节点）数按照一定的比例(例如200倍)扩大后并计算其hash(key)值以均匀分布到圆环上。在进行负载均衡时候，落到虚拟节点的哈希值实际就落到了实际的节点上。由于所有的实际节点是按照相同的比例复制成虚拟节点的，因此解决了节点数较少的情况下哈希值在圆环上均匀分布的问题。</p>

<p><img src="/images/consistent-hashing-03.png" alt="consistent hashing" /></p>

<p>虚拟节点对Consistent Hashing结果的影响
从上图可以看出，在节点数为10个的情况下，每个实际节点的虚拟节点数为实际节点的100-200倍的时候，结果还是很均衡的。</p>

<p>第3段中有这些文字：“但这样的算法方法存在致命问题，如果某一台机器宕机，那么应该落在该机器的请求就无法得到正确的处理，这时需要将当掉的服务器从算法从去除，此时候会有(N-1)/N的服务器的缓存数据需要重新进行计算；”
为何是 (N-1)/N 呢？解释如下：
  比如有 3 台机器，hash值 1-6 在这3台上的分布就是：
  host 1: 1 4
  host 2: 2 5
  host 3: 3 6
  如果挂掉一台，只剩两台，模数取 2 ，那么分布情况就变成：
  host 1: 1 3 5
  host 2: 2 4 6
可以看到，还在数据位置不变的只有2个： 1，2，位置发生改变的有4个，占共6个数据的比率是 4/6 = 2/3
这样的话，受影响的数据太多了，势必太多的数据需要重新从 DB 加载到 cache 中，严重影响性能</p>

<p>【consistent hashing 的办法】
上面提到的 hash 取模，模数取的比较小，一般是负载的数量，而 consistent hashing 的本质是将模数取的比较大，为 2的32次方减1，即一个最大的 32 位整数。然后，就可以从容的安排数据导向了，那个图还是挺直观的
以下部分为一致性哈希算法的一种PHP实现。
下载地址 ：<a href="http://zwzweb.googlecode.com/files/Consistent%20Hashing.php">http://zwzweb.googlecode.com/files/Consistent%20Hashing.php</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/30/jquery-extend-method/">jQuery.extend()函数注释说明</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-08-30T14:11:50+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>30</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>2:11 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><ul>
<li>// 第一个参数是true，则会迭代合并</li>
<li>// 合并两个或更多对象的属性到第一个对象中，jQuery后续的大部分功能都通过该函数扩展</li>
<li>// 通过jQuery.fn.extend扩展的函数，大部分都会调用通过jQuery.extend扩展的同名函数</li>
<li>// 如果传入两个或多个对象，所有对象的属性会被添加到第一个对象target</li>
<li>// 如果只传入一个对象，则将对象的属性添加到jQuery对象中。</li>
<li>// 用这种方式，我们可以为jQuery命名空间增加新的方法。可以用于编写jQuery插件。</li>
<li>// 如果不想改变传入的对象，可以传入一个空对象：$.extend({}, object1, object2);</li>
<li>// 默认合并操作是不迭代的，即便target的某个属性是对象或属性，也会被完全覆盖而不是合并</li>
<li>// 从object原型继承的属性会被拷贝</li>
<li>// undefined值不会被拷贝</li>
<li>// 因为性能原因，JavaScript自带类型的属性不会合并</li>
<li>// jQuery.extend( target, [ object1 ], [ objectN ] )</li>
<li>// jQuery.extend( [ deep ], target, object1, [ objectN ] )</li>
</ul>


<pre>
    jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone,
           target = arguments[0] || {},
           i = 1,
           length = arguments.length,
           deep = false;

        // Handle a deep copy situation
        // 如果第一个参数是boolean型，可能是深度拷贝
        if ( typeof target === "boolean" ) {
           deep = target;
           target = arguments[1] || {};
           // skip the boolean and the target
           // 跳过boolean和target，从第3个开始
           i = 2;
        }

        // Handle case when target is a string or something (possible in deep copy)
        // target不是对象也不是函数，则强制设置为空对象
        if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
           target = {};
        }

        // extend jQuery itself if only one argument is passed
        // 如果只传入一个参数，则认为是对jQuery扩展
        if ( length === i ) {
           target = this;
           --i;
        }

        for ( ; i < length; i++ ) {
           // Only deal with non-null/undefined values
           // 只处理非空参数
           if ( (options = arguments[ i ]) != null ) {
               // Extend the base object
               for ( name in options ) {
                  src = target[ name ];
                  copy = options[ name ];

                  // Prevent never-ending loop
                  // 避免循环引用
                  if ( target === copy ) {
                      continue;
                  }

                  // Recurse if we're merging plain objects or arrays
                  // 深度拷贝且值是纯对象或数组，则递归
                  if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
                      // 如果copy是数组
                      if ( copyIsArray ) {
                         copyIsArray = false;
                         // clone为src的修正值
                         clone = src && jQuery.isArray(src) ? src : [];
                      // 如果copy的是对象
                      } else {
                         // clone为src的修正值
                         clone = src && jQuery.isPlainObject(src) ? src : {};
                      }

                      // Never move original objects, clone them
                      // 递归调用jQuery.extend
                      target[ name ] = jQuery.extend( deep, clone, copy );

                  // Don't bring in undefined values
                  // 不能拷贝空值
                  } else if ( copy !== undefined ) {
                      target[ name ] = copy;
                  }
               }
           }
        }

        // Return the modified object
        // 返回更改后的对象
        return target;
    };
</pre>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/05/30/intr-rsa/">RSA加密算法简单介绍</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2012-05-30T20:40:02+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>30</span><span class='date-suffix'>th</span>, <span class='date-year'>2012</span></span> <span class='time'>8:40 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这种算法1978年就出现了，它是第一个既能用于数据加密也能用于数字签名的算法。它易于理解和操作，也很流行。
   算法的名字以发明者的名字命名：Ron Rivest, AdiShamir 和Leonard Adleman。
   　　RSA算法是一种非对称密码算法，所谓非对称，就是指该算法需要一对密钥，使用其中一个加密，则需要用另一个
   才能解密。
   　　RSA的算法涉及三个参数，n、e、d。
   　　其中，n是两个大质数p、q的积。n的二进制表示时所占用的位数，就是所谓的密钥长度。
   　　e和d是一对相关的值，e可以任意取，但要求满足e&lt;(p-1)<em>(q-1)并具 e与(p-1)</em>(q-1)互质（就是最大公约数为1）；
   再选择d，要求(d<em>e)mod((p-1)</em>(q-1))=1。
   　　(n及e),(n及d)就是密钥对。
   　　RSA加解密的算法完全相同,设M为明文，c为密文，则：
       加密：C=M<sup>e</sup> mod n;
       解密：m=c<sup>d</sup> mod n;
   　　注：上面两式中的e和d可以互换。<br/>
       n d两个数构成公钥，可以告诉别人；
       n e两个数构成私钥，e自己保留，不让任何人知道。
       给别人发送的信息使用私钥e加密,只要别人能用公钥d解开就证明信息是由你发送的,构成了签名机制,起验证身份的作用。
   别人给你发送信息时使用d加密，这样只有拥有e的你能够对其解密,起到数据保密的作用。<br/>
   整理一下：
    为实现RSA的加解密
    最终目标：找三个参数 n,e,d
    1、n = p<em>q (p,q 是两个质数)
    2、
        1)、φ(N)=(p-1)</em>(q-1)
        2)、取任何一个数e,要求满足e&lt;φ(N)并且e与φ(N)互质
    3、(d*e) modφ(N)=1
//================================================================
加密的明文长度不能超过RSA密钥的长度-11，比如1024位的，明文长度不能超过117。 <br/>
密文的长度总是密钥的长度的一半，比如1024位的，密文长度是64，如果是1032位，密文长度是65位。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/23/command-line-skill-of-linux/">Linux命令行技巧</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2012-03-23T13:18:37+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2012</span></span> <span class='time'>1:18 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>编辑命令</h2>

<pre><code>* Ctrl + a ：移到命令行首
* Ctrl + e ：移到命令行尾
* Ctrl + f ：按字符前移（右向）
* Ctrl + b ：按字符后移（左向）
* Alt + f ：按单词前移（右向）
* Alt + b ：按单词后移（左向）
* Ctrl + xx：在命令行首和光标之间移动
* Ctrl + u ：从光标处删除至命令行首
* Ctrl + k ：从光标处删除至命令行尾
* Ctrl + w ：从光标处删除至字首
* Alt + d ：从光标处删除至字尾
* Ctrl + d ：删除光标处的字符
* Ctrl + h ：删除光标前的字符
* Ctrl + y ：粘贴至光标后
* Alt + c ：从光标处更改为首字母大写的单词
* Alt + u ：从光标处更改为全部大写的单词
* Alt + l ：从光标处更改为全部小写的单词
* Ctrl + t ：交换光标处和之前的字符
* Alt + t ：交换光标处和之前的单词
* Alt + Backspace：与 Ctrl + w 相同类似
</code></pre>

<h2>重新执行命令</h2>

<pre><code>* Ctrl + r：逆向搜索命令历史
* Ctrl + g：从历史搜索模式退出
* Ctrl + p：历史中的上一条命令
* Ctrl + n：历史中的下一条命令
* Alt + .：使用上一条命令的最后一个参数
</code></pre>

<h2>控制命令</h2>

<pre><code>* Ctrl + l：清屏
* Ctrl + o：执行当前命令，并选择上一条命令
* Ctrl + s：阻止屏幕输出
* Ctrl + q：允许屏幕输出
* Ctrl + c：终止命令
* Ctrl + z：挂起命令
</code></pre>

<h2>Bang (!) 命令</h2>

<pre><code>* !!：执行上一条命令
* !blah：执行最近的以 blah 开头的命令，如 !ls
* !blah:p：仅打印输出，而不执行
* !$：上一条命令的最后一个参数，与 Alt + . 相同
* !$:p：打印输出 !$ 的内容
* !*：上一条命令的所有参数
* !*:p：打印输出 !* 的内容
* ^blah：删除上一条命令中的 blah
* ^blah^foo：将上一条命令中的 blah 替换为 foo
* ^blah^foo^：将上一条命令中所有的 blah 都替换为 foo
</code></pre>

<h2>注意：</h2>

<pre><code>1. 以上介绍的大多数 Bash 快捷键仅当在 emacs 编辑模式时有效，若你将 Bash 配置为 vi 编辑模式，那将遵循 vi 的按键绑定。Bash 默认为 emacs 编辑模式。如果你的 Bash 不在 emacs 编辑模式，可通过 set -o emacs 设置。
2. ^S、^Q、^C、^Z 是由终端设备处理的，可用 stty 命令设置。
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/02/note-of-yum/">Yum配置笔记</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2012-03-02T10:11:18+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>2</span><span class='date-suffix'>nd</span>, <span class='date-year'>2012</span></span> <span class='time'>10:11 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>YUM 优点</h3>

<p>自动解决包的依赖性的问题能更新的添加/删除/更新/RPM包
便于管理大量系统的更新问题
可以同时配置多个资源库（Repository）
简洁的配置文件(/etc/yum.conf)
保持与RPM数据库的一致性
有一个比较详细的log.可以查看何时升级了什么软件包</p>

<h3>CentOS的镜像站点</h3>

<p>了解 镜像站点的文件结构 对理解 yum 配置文件 .repo 文件有帮助
    <a href="http://mirror-status.centos.org">http://mirror-status.centos.org</a>
    <a href="http://isoredirect.centos.org/centos/5/isos/i386/">http://isoredirect.centos.org/centos/5/isos/i386/</a>
    addons/      本目录包含Centos的addons 仓库
    centosplus/  本目录包含Centos的centosplus 仓库
    extras/      本目录包含Centos的extras 仓库
    fasttrack/   本目录包含Centos的extras 仓库
    isos-dvd/    本目录包含发行版的DVD iso 下载
    isos/        本目录包含发行版 CD iso 下载
    os/          本目录包含发行版(distributions)的仓库
    updates/     本目录包含Centos的updates仓库</p>

<h3>CentOS 的仓库</h3>

<p>仓库(repository) 是一个预备好的目录or 网站，包含了软件包和索引。
yum 可以在仓库中自动定位并获取正确的RPM软件。
镜像服务器为每个版本的Centos分别提供了一些仓库。
Centos中的软件管理工具 yum已经预先配置为使用下列四个仓库：
base: 构成Centos发行版(distributions)的软件包，和光盘上的内容相同
updates: base 仓库中软件包的更新版本
addons: 已编译的但不在发行版(distributions)中的软件包
extras: 一大批附加的软件包
centospuls:　用于增强一些现有软件包的功能(默认未启用)</p>

<h3>CentOS 仓库的目录结构</h3>

<pre><code>updates/
 |--SRPMS                        #源代码目录
 |  |--*.src.rpm                #源代码包目录    
 |    |--repodata/                #源代码的索引文件
 |--i386                        #Intel 32位平台的目录
 |    |--RPMS                        #Intel 32位平台的RPMS目录
 |    |    |--*.i386.rpm            #在intel 32位平台上编译的包文件
 |    |    |--*.centos.noarch.rpm    #与平台无关的已编译的包文件
 |    |--repodata/                #intel 32位平台的索引文件
 |--x68_64                        #64位平台的目录
    |--RPMS                        #64位平台的RPMS目录
    |    |--x68_64.rpm            #在64位平台上编译的包文件
    |    |--*.centos.noarch.rpm    #与平台无关的已编译的包文件
    |--repodata/                #64位平台的索引文件
</code></pre>

<h3>配置YUM客户的更新源</h3>

<p>yum使用reposdir /etc/yum.repos.d 目录下的一系列.repo 文件列出可获取软件包仓库的镜像站点地址.
默认情况下有两个：
Centos-Base.repo: 用于设置远程仓库
Centos-Media.repo: 用于设置本地仓库</p>

<p>yum 目录结构
    /etc
      |&ndash;yum/
      |   |&ndash;/pluginconf.d  <br/>
      |   |&ndash;/yum-updatesd.conf/
      |            |&ndash;downloadonly.conf
      |            |&ndash;fastestmirror.conf
      |            |&ndash;priorities.conf
      |&ndash;yum.conf
      |&ndash;yum.repos.d/
            |&ndash;CentOS-Base.repo
            |&ndash;CentOS-Media.repo</p>

<p>在.repo 文件中，配置语法是分段的，每一段配置一个软件仓库，语法如下：
设置网络更新源
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    [base]  \用于指定仓库
    name=CentOS-$releasever - Base \用于指定易读的仓库名称
    mirrorlist=<a href="http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os">http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os</a> \用于指定本仓库的URL
    #baseurl=<a href="http://mirror.centos.org/centos/$releasever/os/$basearch/">http://mirror.centos.org/centos/$releasever/os/$basearch/</a>
    #        =<a href="ftp://">ftp://</a>  \用于指定远程ftp协议的愿
    #        =file://  \ 用于本地镜像或NFS挂载文件系统
    #nabled=0/1  \用于指定是否使用本地仓库，默认为1，即可用。
    gpgcheck=1  \用于指定是否检查软件包的GPG签名
    gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-5  \用于指定GPG签名文件的URL
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
注：若指定mirrorlist,系统将从Centos 的镜像站点中选择离你最近的仓库。
[$releasever]当前系统的版本号
[$basearch] 当前系统的构架
baseurl 可以指定多个URL ,系统会依次检查你列出的仓库。以便某个服务器宕机时使用另一台服务器</p>

<h3>设置本地更新源</h3>

<p>为了使用 [c5-media]仓库，需将Centos-Base
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    [c5-media]
    name=CentOS-$releasever - Media
    baseurl=file:///media/CentOS/
            file:///media/cdrom/
            file:///media/cdrecorder/
    gpgcheck=1
    enabled=0
    gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-5
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</p>

<h3>设置非官方更新源</h3>

<pre><code>以安置rpmforge 软件包为例在
http://rpm.pbone.net/
http://dag.wieers.com/rpm/
http://rpmforge.net
http://rpm.livna.org
http://freshrpms.net
http://atrpms.net
中找到适用于 Centos 5 的软件包
wget http://................rpmforge-release..... .rpm
rpm -ivh rpmforge-release........... .rpm
rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-rpmforge-*
</code></pre>

<p>安装 rpmforge-release 软件包之后可以看到/etc/yum.repos.d/rpmfoge.repo文件</p>

<p>or建立一个DAG 的仓库
vi /etc/yum.repos.d/dag.repo</p>

<pre><code>[dag]
name=Dag RPM Repository for Red Hat Enterprise Linux
baseurl=http://apt.sw.be/redhat/el$releasever/en/$basearch/dag
gpgcheck=1
enabled=1
gpgkey=http://dag.wieers.com/packages/RPM-GPG-KYE.dag.txt
</code></pre>

<h3>yum 命令工具</h3>

<pre><code>yum check-update            检查可更新的软件包
yum update                    下载更新系统已安装的所有软件把
yum upgrade                    大规模的升级，不同于上面的是,连旧的淘汰的包也升级
yum install &lt;packages&gt;        安装指定的软件包
yum update &lt;packages&gt;        更新指定的软件包
yum remove &lt;packages&gt;        卸载指定的软件包
yum groupinstall &lt;packages&gt;    安装指定的软件组中的软件包
yum groupupdate &lt;packages&gt;    更新 ... ...
yum groupremove &lt;packages&gt;    卸载 ... ...
yum grouplist                查看系统中已经安装的和可以用的软件组
yum list                    列出资源库中所有可以安装or 更新以及已经安装的的rpm包
yum list &lt;regex&gt;             列出资源库中与正则表达式匹配的可以安装或更新以及已经安装的rpm包
yum list available             列出资源库中所有可以安装的rpm包
yum list available &lt;regex&gt;     列出资源库中与正则表达式匹配的所有可以安装的rpm包
yum list updates             列出资源库中所有可以更新的rpm包
yum list updates &lt;regex&gt;     列出资源库中与正则表达式匹配的所有可以更新的rpm包
yum list installed             列出资源库中所有已经安装的rpm包
yum list installed &lt;regex&gt;     列出资源库中与正则表达式匹配的所有已经安装的rpm包
yum list extras             列出已经安装的但是不包含在资源库中的rpm包
yum list extras &lt;regex&gt;     列出与正则表达式匹配的已经安装的但是不包含在资源库中的rpm包
yum list recent             列出最近被添加到资源库中的软件包
yum search &lt;regex&gt;             检测所有可用的软件的名称、描述、概述和已列出的维护者，查找与正则表达式匹配的值
yum provides &lt;regex&gt;         检测软件包中包含的文件以及软件提供的功能，查找与正则表达式匹配的值
yum clean headers             清除缓存中的rpm头文件
yum clean packages             清除缓存中rpm包文件
yum clean all                 清除缓存中的rpm头文件和包文件
yum deplist &lt;packages&gt;         显示软件包的依赖信息
</code></pre>

<p>第一次使用yum或者yum资源库有更新是.yum会自动下载所有需要的headers 放置于/var/cache/yum
还可以用yum info 命令列出包信息,yum info 可用的参数与 yum list的相同
yum 命令还可以使用 -y 参数 回答命令运行时所提出的问题。</p>

<p>yum update 升级时 排除升级内核
yum update 排除升级内核，方法有两个:
1.修改yum的配置文件 vi /etc/yum.conf，在[main]的最后添加exclude=kernel<em>
2.直接在yum的命令行执行如下的命令：
yum –exclude=kernel</em> update</p>

<h3>附：</h3>

<p>当仓库配置文件 *.repo 使用了多个URL yum-fastestmirror  可以自动选择最快的镜像站点
    yum -y install yum-fastestmirror
    yum-fastestmirror 的配置文件在 /etc/yum/pluginconf.d/fastestmirror.conf 默认不需要修改。</p>

<pre><code>yum -updatesd
rpm -ql yum-updatesd
yum -cron
yum -y install yum-cron
rpm -ql yum-cron
/etc
    |--/cron.daily/yum.cron        每日更新脚本
    |--/cron.weekly/yum.cron    每周更新脚本
    |--/rc.d/int.d/yum            启动脚本
    |--/yum/yum-daily.yum
/usr/share/doc/yum-cron-0.1
                        |--/COPYING
                        |--/README
</code></pre>

<p>使用yum下载而不安装rpm包
先安装yum-downloadonly
    # yum install yum-downloadonly</p>

<p>安装后使用方法如下:
    # yum update httpd -y &ndash;downloadonly   ###下载到默认目录  /var/cache/yum
    OR
    # yum update httpd -y &ndash;downloadonly &ndash;downloaddir=/opt     ##下载到指定目录
    # yum install perl-MailTools &ndash;downloadonly &ndash;downloaddir=/opt -y     ##如果软件已经下载过了，必须使用这个来下载</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/3">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/index.html">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2017/09/26/mysql-optimize-note/">Mysql-optimize-note</a>
      </li>
    
      <li class="post">
        <a href="/blog/2017/09/19/laravel-learn-notes/">Laravel_learn_notes</a>
      </li>
    
      <li class="post">
        <a href="/blog/2017/09/06/laravel-5-dot-4-migrate-error-specified-key-was-too-long-error/">Laravel 5.4 Migrate error:Specified Key Was Too Long Error</a>
      </li>
    
      <li class="post">
        <a href="/blog/2017/08/29/golang-printf-type/">Golang Printf Type</a>
      </li>
    
      <li class="post">
        <a href="/blog/2017/08/21/qianghongbao-jiandanshixian/">微信抢红包实现</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2017 - wang yu -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
