<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Computer | 陌上花开 可缓缓归矣]]></title>
  <link href="http://juelite.github.io/blog/categories/computer/atom.xml" rel="self"/>
  <link href="http://juelite.github.io/"/>
  <updated>2017-08-10T17:55:53+08:00</updated>
  <id>http://juelite.github.io/</id>
  <author>
    <name><![CDATA[juelite]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Htop是个好东西]]></title>
    <link href="http://juelite.github.io/blog/2015/01/06/htop/"/>
    <updated>2015-01-06T13:49:16+08:00</updated>
    <id>http://juelite.github.io/blog/2015/01/06/htop</id>
    <content type="html"><![CDATA[<pre><code>Htop是一款运行于Linux系统监控与进程管理软件，用于取代Unix下传统的top。与top只提供最消耗资源的进程列表不同，htop提供所有进程的列表，并且使用彩色标识出处理器、swap和内存状态。
</code></pre>

<p>用户一般可以在top无法提供详尽系统信息的情况下选择安装并使用htop。比如，在查找应用程序的内存泄漏问题时。与top相比，htop提供更方便、光标控制的界面来杀死进程。
htop用C语言编写，采用了ncurses库。htop的名称源于其作者的名字。</p>

<h2>安装-htop</h2>

<pre><code>yum -y install ncurses-devel #htop依赖ncurses
cd /opt
wget -c http://ncu.dl.sourceforge.net/project/htop/htop/1.0.2/htop-1.0.2.tar.gz
tar xzf htop-1.0.2.tar.gz
cd htop-1.0.2
./configure
make &amp;&amp; make install
</code></pre>

<h2>示例图片</h2>

<p><img src="/images/2015/htop.gif" title="示例图片" alt="示例图片" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一致性哈希算法浅析]]></title>
    <link href="http://juelite.github.io/blog/2014/01/31/consistent-hashing/"/>
    <updated>2014-01-31T10:27:40+08:00</updated>
    <id>http://juelite.github.io/blog/2014/01/31/consistent-hashing</id>
    <content type="html"><![CDATA[<p>在做服务器负载均衡时候可供选择的负载均衡的算法有很多，包括：</p>

<ul>
<li>轮循算法（Round Robin）</li>
<li>哈希算法（HASH）</li>
<li>最少连接算法（Least Connection）</li>
<li>响应速度算法（Response Time）</li>
<li>加权法（Weighted ）等</li>
</ul>


<p> 其中哈希算法是最为常用的算法.
典型的应用场景是： 有N台服务器提供缓存服务，需要对服务器进行负载均衡，将请求平均分发到每台服务器上，每台机器负责1/N的服务。
常用的算法是对hash结果取余数 (hash() mod N)：对机器编号从0到N-1，按照自定义的hash()算法，对每个请求的hash()值按N取模，得到余数i，然后将请求分发到编号为i的机器。但这样的算法方法存在致命问题，如果某一台机器宕机，那么应该落在该机器的请求就无法得到正确的处理，这时需要将当掉的服务器从算法从去除，此时候会有(N-1)/N的服务器的缓存数据需要重新进行计算；如果新增一台机器，会有N /(N+1)的服务器的缓存数据需要进行重新计算。对于系统而言，这通常是不可接受的颠簸（因为这意味着大量缓存的失效或者数据需要转移）。那么，如何设计一个负载均衡策略，使得受到影响的请求尽可能的少呢？
在Memcached、Key-Value Store、Bittorrent DHT、LVS中都采用了Consistent Hashing算法，可以说Consistent Hashing 是分布式系统负载均衡的首选算法。
1、Consistent Hashing算法描述
下面以Memcached中的Consisten Hashing算法为例说明。
由于hash算法结果一般为unsigned int型，因此对于hash函数的结果应该均匀分布在[0,232-1]间，如果我们把一个圆环用232 个点来进行均匀切割，首先按照hash(key)函数算出服务器（节点）的哈希值， 并将其分布到0～232的圆上。
用同样的hash(key)函数求出需要存储数据的键的哈希值，并映射到圆上。然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器（节点）上。</p>

<p><img src="/images/consistent-hashing-01.png" alt="consistent hashing" /></p>

<p>Consistent Hashing原理示意图
新增一个节点的时候，只有在圆环上新增节点逆时针方向的第一个节点的数据会受到影响。删除一个节点的时候，只有在圆环上原来删除节点顺时针方向的第一个节点的数据会受到影响，因此通过Consistent Hashing很好地解决了负载均衡中由于新增节点、删除节点引起的hash值颠簸问题。</p>

<p><img src="/images/consistent-hashing-02.png" alt="consistent hashing" /></p>

<p>Consistent Hashing添加服务器示意图
虚拟节点（virtual nodes）：之所以要引进虚拟节点是因为在服务器（节点）数较少的情况下（例如只有3台服务器），通过hash(key)算出节点的哈希值在圆环上并不是均匀分布的（稀疏的），仍然会出现各节点负载不均衡的问题。虚拟节点可以认为是实际节点的复制品（replicas），本质上与实际节点实际上是一样的（key并不相同）。引入虚拟节点后，通过将每个实际的服务器（节点）数按照一定的比例(例如200倍)扩大后并计算其hash(key)值以均匀分布到圆环上。在进行负载均衡时候，落到虚拟节点的哈希值实际就落到了实际的节点上。由于所有的实际节点是按照相同的比例复制成虚拟节点的，因此解决了节点数较少的情况下哈希值在圆环上均匀分布的问题。</p>

<p><img src="/images/consistent-hashing-03.png" alt="consistent hashing" /></p>

<p>虚拟节点对Consistent Hashing结果的影响
从上图可以看出，在节点数为10个的情况下，每个实际节点的虚拟节点数为实际节点的100-200倍的时候，结果还是很均衡的。</p>

<p>第3段中有这些文字：“但这样的算法方法存在致命问题，如果某一台机器宕机，那么应该落在该机器的请求就无法得到正确的处理，这时需要将当掉的服务器从算法从去除，此时候会有(N-1)/N的服务器的缓存数据需要重新进行计算；”
为何是 (N-1)/N 呢？解释如下：
  比如有 3 台机器，hash值 1-6 在这3台上的分布就是：
  host 1: 1 4
  host 2: 2 5
  host 3: 3 6
  如果挂掉一台，只剩两台，模数取 2 ，那么分布情况就变成：
  host 1: 1 3 5
  host 2: 2 4 6
可以看到，还在数据位置不变的只有2个： 1，2，位置发生改变的有4个，占共6个数据的比率是 4/6 = 2/3
这样的话，受影响的数据太多了，势必太多的数据需要重新从 DB 加载到 cache 中，严重影响性能</p>

<p>【consistent hashing 的办法】
上面提到的 hash 取模，模数取的比较小，一般是负载的数量，而 consistent hashing 的本质是将模数取的比较大，为 2的32次方减1，即一个最大的 32 位整数。然后，就可以从容的安排数据导向了，那个图还是挺直观的
以下部分为一致性哈希算法的一种PHP实现。
下载地址 ：<a href="http://zwzweb.googlecode.com/files/Consistent%20Hashing.php">http://zwzweb.googlecode.com/files/Consistent%20Hashing.php</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解Mysql字符集设置]]></title>
    <link href="http://juelite.github.io/blog/2012/01/17/understand-mysql-charset/"/>
    <updated>2012-01-17T10:39:27+08:00</updated>
    <id>http://juelite.github.io/blog/2012/01/17/understand-mysql-charset</id>
    <content type="html"><![CDATA[<h3>基本概念</h3>

<ul>
<li>字符(Character)是指人类语言中最小的表义符号。例如’A’、’B’等；</li>
<li>给定一系列字符，对每个字符赋予一个数值，用数值来代表对应的字符，这一数值就是字符的编码(Encoding)例如，我们给字符’A’赋予数值0，给字符’B’赋予数值1，则0就是字符’A’的编码；</li>
<li>给定一系列字符并赋予对应的编码后，所有这些字符和编码对组成的集合就是字符集(Character Set)。例如，给定字符列表为{’A’,’B’}时，{’A’=>0, ‘B’=>1}就是一个字符集；</li>
<li>字符序(Collation)是指在同一字符集内字符之间的比较规则；</li>
<li>确定字符序后，才能在一个字符集上定义什么是等价的字符，以及字符之间的大小关系；</li>
<li>每个字符序唯一对应一种字符集，但一个字符集可以对应多种字符序，其中有一个是默认字符序(Default Collation)；</li>
<li>MySQL中的字符序名称遵从命名惯例：以字符序对应的字符集名称开头；以<em>ci(表示大小写不敏感)、</em>cs(表示大小写敏感)或_bin(表示按编码值比较)结尾。例如：在字符序“utf8_general_ci”下，字符“a”和“A”是等价的；</li>
</ul>


<h3>MySQL字符集设置</h3>

<p>• 系统变量：
    – character_set_server：默认的内部操作字符集
    – character_set_client：客户端来源数据使用的字符集
    – character_set_connection：连接层字符集
    – character_set_results：查询结果字符集
    – character_set_database：当前选中数据库的默认字符集
    – character_set_system：系统元数据(字段名等)字符集
    – 还有以collation<em>开头的同上面对应的变量，用来描述字符序。
• 用introducer指定文本字符串的字符集：
    – 格式为：[</em>charset] ’string’ [COLLATE collation]
    – 例如：
        • SELECT <em>latin1 ’string’;
        • SELECT </em>utf8 ‘你好’ COLLATE utf8_general_ci;
    – 由introducer修饰的文本字符串在请求过程中不经过多余的转码，直接转换为内部字符集处理。</p>

<h3>MySQL中的字符集转换过程</h3>

<pre><code>1. MySQL Server收到请求时将请求数据从character_set_client转换为character_set_connection；
2. 进行内部操作前将请求数据从character_set_connection转换为内部操作字符集，其确定方法如下：
    • 使用每个数据字段的CHARACTER SET设定值；
    • 若上述值不存在，则使用对应数据表的DEFAULT CHARACTER SET设定值(MySQL扩展，非SQL标准)；
    • 若上述值不存在，则使用对应数据库的DEFAULT CHARACTER SET设定值；
    • 若上述值不存在，则使用character_set_server设定值。
3. 将操作结果从内部操作字符集转换为character_set_results。
</code></pre>

<p><img src="/images/understand-mysql-charset-01.jpg" alt="understand-mysql-charset" /></p>

<h3>常见问题解析</h3>

<ul>
<li>向默认字符集为utf8的数据表插入utf8编码的数据前没有设置连接字符集，查询时设置连接字符集为utf8</li>
<li>插入时根据MySQL服务器的默认设置，character_set_client、character_set_connection和character_set_results均为latin1；</li>
<li>插入操作的数据将经过latin1=>latin1=>utf8的字符集转换过程，这一过程中每个插入的汉字都会从原始的3个字节变成6个字节保存；</li>
<li>查询时的结果将经过utf8=>utf8的字符集转换过程，将保存的6个字节原封不动返回，产生乱码……</li>
</ul>


<p><img src="/images/understand-mysql-charset-02.jpg" alt="understand-mysql-charset" /></p>

<ul>
<li>向默认字符集为latin1的数据表插入utf8编码的数据前设置了连接字符集为utf8</li>
<li>插入时根据连接字符集设置，character_set_client、character_set_connection和character_set_results均为utf8；</li>
<li>插入数据将经过utf8=>utf8=>latin1的字符集转换，若原始数据中含有\u0000~\u00ff范围以外的Unicode字 符，会因为无法在latin1字符集中表示而被转换为“?”(0×3F)符号，以后查询时不管连接字符集设置如何都无法恢复其内容了。</li>
</ul>


<p><img src="/images/understand-mysql-charset-02.jpg" alt="understand-mysql-charset" /></p>

<h3>检测字符集问题的一些手段</h3>

<ul>
<li>SHOW CHARACTER SET;</li>
<li>SHOW COLLATION;</li>
<li>SHOW VARIABLES LIKE ‘character%’;</li>
<li>SHOW VARIABLES LIKE ‘collation%’;</li>
<li>SQL函数HEX、LENGTH、CHAR_LENGTH</li>
<li>SQL函数CHARSET、COLLATION</li>
</ul>


<h3>使用MySQL字符集时的建议</h3>

<ul>
<li>建立数据库/表和进行数据库操作时尽量显式指出使用的字符集，而不是依赖于MySQL的默认设置，否则MySQL升级时可能带来很大困扰；</li>
<li>数据库和连接字符集都使用latin1时虽然大部分情况下都可以解决乱码问题，但缺点是无法以字符为单位来进行SQL操作，一般情况下将数据库和连接字符集都置为utf8是较好的选择；</li>
<li>使用mysql C API时，初始化数据库句柄后马上用mysql_options设定MYSQL_SET_CHARSET_NAME属性为utf8，这样就不用显式地用 SET NAMES语句指定连接字符集，且用mysql_ping重连断开的长连接时也会把连接字符集重置为utf8；</li>
<li>对于mysql PHP API，一般页面级的PHP程序总运行时间较短，在连接到数据库以后显式用SET NAMES语句设置一次连接字符集即可；但当使用长连接时，请注意保持连接通畅并在断开重连后用SET NAMES语句显式重置连接字符集。</li>
</ul>


<h3>其他注意事项</h3>

<ul>
<li>my.cnf中的default_character_set设置只影响mysql命令连接服务器时的连接字符集，不会对使用libmysqlclient库的应用程序产生任何作用！</li>
<li>对字段进行的SQL函数操作通常都是以内部操作字符集进行的，不受连接字符集设置的影响。</li>
<li>SQL语句中的裸字符串会受到连接字符集或introducer设置的影响，对于比较之类的操作可能产生完全不同的结果，需要小心！</li>
</ul>

]]></content>
  </entry>
  
</feed>
